// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: meals.sql

package sqlc

import (
	"context"
	"database/sql"
)

const deleteMeal = `-- name: DeleteMeal :exec
DELETE FROM meals
WHERE id = ?1
`

func (q *Queries) DeleteMeal(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteMeal, id)
	return err
}

const getAllMeals = `-- name: GetAllMeals :many
SELECT id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic FROM meals
WHERE isPublic = TRUE
ORDER BY category DESC
`

func (q *Queries) GetAllMeals(ctx context.Context) ([]Meal, error) {
	rows, err := q.db.QueryContext(ctx, getAllMeals)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meal
	for rows.Next() {
		var i Meal
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Category,
			&i.Servings,
			&i.Description,
			&i.LightVersionInstructions,
			&i.Instructions,
			&i.ImageUrl,
			&i.ImageAlt,
			&i.Calories,
			&i.Protein,
			&i.CookTime,
			&i.PrepTime,
			&i.TotalTime,
			&i.WashingEffort,
			&i.PeelingEffort,
			&i.CuttingEffort,
			&i.ItemsRequired,
			&i.Ingredients,
			&i.TotalEffort,
			&i.Likes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMealsPaginated = `-- name: GetAllMealsPaginated :many
SELECT id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic FROM meals
WHERE isPublic = TRUE
ORDER BY created_at DESC
LIMIT ?1 OFFSET ?2
`

type GetAllMealsPaginatedParams struct {
	Limit  int64
	Offset int64
}

func (q *Queries) GetAllMealsPaginated(ctx context.Context, arg GetAllMealsPaginatedParams) ([]Meal, error) {
	rows, err := q.db.QueryContext(ctx, getAllMealsPaginated, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meal
	for rows.Next() {
		var i Meal
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Category,
			&i.Servings,
			&i.Description,
			&i.LightVersionInstructions,
			&i.Instructions,
			&i.ImageUrl,
			&i.ImageAlt,
			&i.Calories,
			&i.Protein,
			&i.CookTime,
			&i.PrepTime,
			&i.TotalTime,
			&i.WashingEffort,
			&i.PeelingEffort,
			&i.CuttingEffort,
			&i.ItemsRequired,
			&i.Ingredients,
			&i.TotalEffort,
			&i.Likes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFastestMeals = `-- name: GetFastestMeals :many
SELECT id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic FROM meals
ORDER BY total_time ASC
`

func (q *Queries) GetFastestMeals(ctx context.Context) ([]Meal, error) {
	rows, err := q.db.QueryContext(ctx, getFastestMeals)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meal
	for rows.Next() {
		var i Meal
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Category,
			&i.Servings,
			&i.Description,
			&i.LightVersionInstructions,
			&i.Instructions,
			&i.ImageUrl,
			&i.ImageAlt,
			&i.Calories,
			&i.Protein,
			&i.CookTime,
			&i.PrepTime,
			&i.TotalTime,
			&i.WashingEffort,
			&i.PeelingEffort,
			&i.CuttingEffort,
			&i.ItemsRequired,
			&i.Ingredients,
			&i.TotalEffort,
			&i.Likes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHighProteinMeals = `-- name: GetHighProteinMeals :many
SELECT id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic FROM meals
ORDER BY protein DESC
`

func (q *Queries) GetHighProteinMeals(ctx context.Context) ([]Meal, error) {
	rows, err := q.db.QueryContext(ctx, getHighProteinMeals)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meal
	for rows.Next() {
		var i Meal
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Category,
			&i.Servings,
			&i.Description,
			&i.LightVersionInstructions,
			&i.Instructions,
			&i.ImageUrl,
			&i.ImageAlt,
			&i.Calories,
			&i.Protein,
			&i.CookTime,
			&i.PrepTime,
			&i.TotalTime,
			&i.WashingEffort,
			&i.PeelingEffort,
			&i.CuttingEffort,
			&i.ItemsRequired,
			&i.Ingredients,
			&i.TotalEffort,
			&i.Likes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMealByID = `-- name: GetMealByID :one
SELECT id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic FROM meals
WHERE id = ?1
`

func (q *Queries) GetMealByID(ctx context.Context, id int64) (Meal, error) {
	row := q.db.QueryRowContext(ctx, getMealByID, id)
	var i Meal
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Category,
		&i.Servings,
		&i.Description,
		&i.LightVersionInstructions,
		&i.Instructions,
		&i.ImageUrl,
		&i.ImageAlt,
		&i.Calories,
		&i.Protein,
		&i.CookTime,
		&i.PrepTime,
		&i.TotalTime,
		&i.WashingEffort,
		&i.PeelingEffort,
		&i.CuttingEffort,
		&i.ItemsRequired,
		&i.Ingredients,
		&i.TotalEffort,
		&i.Likes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsPublic,
	)
	return i, err
}

const getMealByIDs = `-- name: GetMealByIDs :many
SELECT id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic FROM meals
WHERE id IN (?1, ?2, ?3)
`

type GetMealByIDsParams struct {
	ID   int64
	ID_2 int64
	ID_3 int64
}

func (q *Queries) GetMealByIDs(ctx context.Context, arg GetMealByIDsParams) ([]Meal, error) {
	rows, err := q.db.QueryContext(ctx, getMealByIDs, arg.ID, arg.ID_2, arg.ID_3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meal
	for rows.Next() {
		var i Meal
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Category,
			&i.Servings,
			&i.Description,
			&i.LightVersionInstructions,
			&i.Instructions,
			&i.ImageUrl,
			&i.ImageAlt,
			&i.Calories,
			&i.Protein,
			&i.CookTime,
			&i.PrepTime,
			&i.TotalTime,
			&i.WashingEffort,
			&i.PeelingEffort,
			&i.CuttingEffort,
			&i.ItemsRequired,
			&i.Ingredients,
			&i.TotalEffort,
			&i.Likes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMealBySlug = `-- name: GetMealBySlug :one
SELECT id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic FROM meals
WHERE slug = ?1
`

func (q *Queries) GetMealBySlug(ctx context.Context, slug sql.NullString) (Meal, error) {
	row := q.db.QueryRowContext(ctx, getMealBySlug, slug)
	var i Meal
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Category,
		&i.Servings,
		&i.Description,
		&i.LightVersionInstructions,
		&i.Instructions,
		&i.ImageUrl,
		&i.ImageAlt,
		&i.Calories,
		&i.Protein,
		&i.CookTime,
		&i.PrepTime,
		&i.TotalTime,
		&i.WashingEffort,
		&i.PeelingEffort,
		&i.CuttingEffort,
		&i.ItemsRequired,
		&i.Ingredients,
		&i.TotalEffort,
		&i.Likes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsPublic,
	)
	return i, err
}

const getMealsByCalories = `-- name: GetMealsByCalories :many
SELECT id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic FROM meals
ORDER BY calories ASC
`

func (q *Queries) GetMealsByCalories(ctx context.Context) ([]Meal, error) {
	rows, err := q.db.QueryContext(ctx, getMealsByCalories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meal
	for rows.Next() {
		var i Meal
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Category,
			&i.Servings,
			&i.Description,
			&i.LightVersionInstructions,
			&i.Instructions,
			&i.ImageUrl,
			&i.ImageAlt,
			&i.Calories,
			&i.Protein,
			&i.CookTime,
			&i.PrepTime,
			&i.TotalTime,
			&i.WashingEffort,
			&i.PeelingEffort,
			&i.CuttingEffort,
			&i.ItemsRequired,
			&i.Ingredients,
			&i.TotalEffort,
			&i.Likes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMealsByEffort = `-- name: GetMealsByEffort :many
SELECT id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic FROM meals
ORDER BY total_effort ASC
`

func (q *Queries) GetMealsByEffort(ctx context.Context) ([]Meal, error) {
	rows, err := q.db.QueryContext(ctx, getMealsByEffort)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meal
	for rows.Next() {
		var i Meal
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Category,
			&i.Servings,
			&i.Description,
			&i.LightVersionInstructions,
			&i.Instructions,
			&i.ImageUrl,
			&i.ImageAlt,
			&i.Calories,
			&i.Protein,
			&i.CookTime,
			&i.PrepTime,
			&i.TotalTime,
			&i.WashingEffort,
			&i.PeelingEffort,
			&i.CuttingEffort,
			&i.ItemsRequired,
			&i.Ingredients,
			&i.TotalEffort,
			&i.Likes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMealsForOnePerson = `-- name: GetMealsForOnePerson :many
SELECT id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic FROM meals
WHERE servings = 1 AND category LIKE '%dinner%'
ORDER BY total_time ASC
`

func (q *Queries) GetMealsForOnePerson(ctx context.Context) ([]Meal, error) {
	rows, err := q.db.QueryContext(ctx, getMealsForOnePerson)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meal
	for rows.Next() {
		var i Meal
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Category,
			&i.Servings,
			&i.Description,
			&i.LightVersionInstructions,
			&i.Instructions,
			&i.ImageUrl,
			&i.ImageAlt,
			&i.Calories,
			&i.Protein,
			&i.CookTime,
			&i.PrepTime,
			&i.TotalTime,
			&i.WashingEffort,
			&i.PeelingEffort,
			&i.CuttingEffort,
			&i.ItemsRequired,
			&i.Ingredients,
			&i.TotalEffort,
			&i.Likes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMealsWithMinimumIngredients = `-- name: GetMealsWithMinimumIngredients :many
SELECT id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic FROM meals
ORDER BY LENGTH(ingredients) ASC
`

func (q *Queries) GetMealsWithMinimumIngredients(ctx context.Context) ([]Meal, error) {
	rows, err := q.db.QueryContext(ctx, getMealsWithMinimumIngredients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meal
	for rows.Next() {
		var i Meal
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Category,
			&i.Servings,
			&i.Description,
			&i.LightVersionInstructions,
			&i.Instructions,
			&i.ImageUrl,
			&i.ImageAlt,
			&i.Calories,
			&i.Protein,
			&i.CookTime,
			&i.PrepTime,
			&i.TotalTime,
			&i.WashingEffort,
			&i.PeelingEffort,
			&i.CuttingEffort,
			&i.ItemsRequired,
			&i.Ingredients,
			&i.TotalEffort,
			&i.Likes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMealsWithMinimumWashing = `-- name: GetMealsWithMinimumWashing :many
SELECT id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic FROM meals
ORDER BY washing_effort ASC
`

func (q *Queries) GetMealsWithMinimumWashing(ctx context.Context) ([]Meal, error) {
	rows, err := q.db.QueryContext(ctx, getMealsWithMinimumWashing)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meal
	for rows.Next() {
		var i Meal
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Category,
			&i.Servings,
			&i.Description,
			&i.LightVersionInstructions,
			&i.Instructions,
			&i.ImageUrl,
			&i.ImageAlt,
			&i.Calories,
			&i.Protein,
			&i.CookTime,
			&i.PrepTime,
			&i.TotalTime,
			&i.WashingEffort,
			&i.PeelingEffort,
			&i.CuttingEffort,
			&i.ItemsRequired,
			&i.Ingredients,
			&i.TotalEffort,
			&i.Likes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMealsWithNoCutting = `-- name: GetMealsWithNoCutting :many
SELECT id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic FROM meals
ORDER BY cutting_effort ASC
`

func (q *Queries) GetMealsWithNoCutting(ctx context.Context) ([]Meal, error) {
	rows, err := q.db.QueryContext(ctx, getMealsWithNoCutting)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meal
	for rows.Next() {
		var i Meal
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Category,
			&i.Servings,
			&i.Description,
			&i.LightVersionInstructions,
			&i.Instructions,
			&i.ImageUrl,
			&i.ImageAlt,
			&i.Calories,
			&i.Protein,
			&i.CookTime,
			&i.PrepTime,
			&i.TotalTime,
			&i.WashingEffort,
			&i.PeelingEffort,
			&i.CuttingEffort,
			&i.ItemsRequired,
			&i.Ingredients,
			&i.TotalEffort,
			&i.Likes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMealsWithNoPeeling = `-- name: GetMealsWithNoPeeling :many
SELECT id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic FROM meals
ORDER BY peeling_effort ASC
`

func (q *Queries) GetMealsWithNoPeeling(ctx context.Context) ([]Meal, error) {
	rows, err := q.db.QueryContext(ctx, getMealsWithNoPeeling)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meal
	for rows.Next() {
		var i Meal
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Category,
			&i.Servings,
			&i.Description,
			&i.LightVersionInstructions,
			&i.Instructions,
			&i.ImageUrl,
			&i.ImageAlt,
			&i.Calories,
			&i.Protein,
			&i.CookTime,
			&i.PrepTime,
			&i.TotalTime,
			&i.WashingEffort,
			&i.PeelingEffort,
			&i.CuttingEffort,
			&i.ItemsRequired,
			&i.Ingredients,
			&i.TotalEffort,
			&i.Likes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMostLikedMeals = `-- name: GetMostLikedMeals :many
SELECT id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic FROM meals
ORDER BY likes DESC
LIMIT ?1
`

func (q *Queries) GetMostLikedMeals(ctx context.Context, limit int64) ([]Meal, error) {
	rows, err := q.db.QueryContext(ctx, getMostLikedMeals, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meal
	for rows.Next() {
		var i Meal
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Category,
			&i.Servings,
			&i.Description,
			&i.LightVersionInstructions,
			&i.Instructions,
			&i.ImageUrl,
			&i.ImageAlt,
			&i.Calories,
			&i.Protein,
			&i.CookTime,
			&i.PrepTime,
			&i.TotalTime,
			&i.WashingEffort,
			&i.PeelingEffort,
			&i.CuttingEffort,
			&i.ItemsRequired,
			&i.Ingredients,
			&i.TotalEffort,
			&i.Likes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNewestMeals = `-- name: GetNewestMeals :many
SELECT id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic FROM meals
ORDER BY created_at DESC
LIMIT ?1
`

func (q *Queries) GetNewestMeals(ctx context.Context, limit int64) ([]Meal, error) {
	rows, err := q.db.QueryContext(ctx, getNewestMeals, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Meal
	for rows.Next() {
		var i Meal
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Name,
			&i.Category,
			&i.Servings,
			&i.Description,
			&i.LightVersionInstructions,
			&i.Instructions,
			&i.ImageUrl,
			&i.ImageAlt,
			&i.Calories,
			&i.Protein,
			&i.CookTime,
			&i.PrepTime,
			&i.TotalTime,
			&i.WashingEffort,
			&i.PeelingEffort,
			&i.CuttingEffort,
			&i.ItemsRequired,
			&i.Ingredients,
			&i.TotalEffort,
			&i.Likes,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPublic,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertMeal = `-- name: InsertMeal :one
INSERT INTO meals (
    name, slug, category, description, light_version_instructions, instructions, image_url, calories, protein,
    cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, servings, updated_at
) VALUES (
    ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10, ?11, ?12, ?13, ?14, ?15, ?16, ?17, ?18, ?19, CURRENT_TIMESTAMP
)
RETURNING id, slug, name, category, servings, description, light_version_instructions, instructions, image_url, image_alt, calories, protein, cook_time, prep_time, total_time, washing_effort, peeling_effort, cutting_effort, items_required, ingredients, total_effort, likes, created_at, updated_at, isPublic
`

type InsertMealParams struct {
	Name                     string
	Slug                     sql.NullString
	Category                 string
	Description              string
	LightVersionInstructions sql.NullString
	Instructions             string
	ImageUrl                 string
	Calories                 int64
	Protein                  int64
	CookTime                 int64
	PrepTime                 int64
	TotalTime                int64
	WashingEffort            int64
	PeelingEffort            int64
	CuttingEffort            int64
	ItemsRequired            string
	Ingredients              string
	TotalEffort              int64
	Servings                 int64
}

func (q *Queries) InsertMeal(ctx context.Context, arg InsertMealParams) (Meal, error) {
	row := q.db.QueryRowContext(ctx, insertMeal,
		arg.Name,
		arg.Slug,
		arg.Category,
		arg.Description,
		arg.LightVersionInstructions,
		arg.Instructions,
		arg.ImageUrl,
		arg.Calories,
		arg.Protein,
		arg.CookTime,
		arg.PrepTime,
		arg.TotalTime,
		arg.WashingEffort,
		arg.PeelingEffort,
		arg.CuttingEffort,
		arg.ItemsRequired,
		arg.Ingredients,
		arg.TotalEffort,
		arg.Servings,
	)
	var i Meal
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Name,
		&i.Category,
		&i.Servings,
		&i.Description,
		&i.LightVersionInstructions,
		&i.Instructions,
		&i.ImageUrl,
		&i.ImageAlt,
		&i.Calories,
		&i.Protein,
		&i.CookTime,
		&i.PrepTime,
		&i.TotalTime,
		&i.WashingEffort,
		&i.PeelingEffort,
		&i.CuttingEffort,
		&i.ItemsRequired,
		&i.Ingredients,
		&i.TotalEffort,
		&i.Likes,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsPublic,
	)
	return i, err
}

const updateMeal = `-- name: UpdateMeal :exec
UPDATE meals
SET
    name = ?2,
    category = ?3,
    description = ?4,
    light_version_instructions = ?5,
    instructions = ?6,
    image_url = ?7,
    image_alt = ?8,
    calories = ?9,
    protein = ?10,
    cook_time = ?11,
    prep_time = ?12,
    total_time = ?13,
    washing_effort = ?14,
    peeling_effort = ?15,
    cutting_effort = ?16,
    items_required = ?17,
    ingredients = ?18,
    total_effort = ?19,
    servings = ?20,
    slug = ?21,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?1
`

type UpdateMealParams struct {
	ID                       int64
	Name                     string
	Category                 string
	Description              string
	LightVersionInstructions sql.NullString
	Instructions             string
	ImageUrl                 string
	ImageAlt                 sql.NullString
	Calories                 int64
	Protein                  int64
	CookTime                 int64
	PrepTime                 int64
	TotalTime                int64
	WashingEffort            int64
	PeelingEffort            int64
	CuttingEffort            int64
	ItemsRequired            string
	Ingredients              string
	TotalEffort              int64
	Servings                 int64
	Slug                     sql.NullString
}

func (q *Queries) UpdateMeal(ctx context.Context, arg UpdateMealParams) error {
	_, err := q.db.ExecContext(ctx, updateMeal,
		arg.ID,
		arg.Name,
		arg.Category,
		arg.Description,
		arg.LightVersionInstructions,
		arg.Instructions,
		arg.ImageUrl,
		arg.ImageAlt,
		arg.Calories,
		arg.Protein,
		arg.CookTime,
		arg.PrepTime,
		arg.TotalTime,
		arg.WashingEffort,
		arg.PeelingEffort,
		arg.CuttingEffort,
		arg.ItemsRequired,
		arg.Ingredients,
		arg.TotalEffort,
		arg.Servings,
		arg.Slug,
	)
	return err
}

const updateMealLikes = `-- name: UpdateMealLikes :exec
UPDATE meals
SET
    likes = likes + 1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = ?1
`

func (q *Queries) UpdateMealLikes(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, updateMealLikes, id)
	return err
}
